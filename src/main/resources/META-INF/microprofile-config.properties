# Quarkus settings can also be put in application.properties
quarkus.http.port=8080
quarkus.http.test-port=8081

# Application configs
hello.message = Hello from Quarkus
niru.text = Her er data som kommer i retyur

# MongoDB config
mongodb.url = mongodb://localhost:27017

# Typesafe REST Client against external user service https://jsonplaceholder.typicode.com/users
userservice.url = https://jsonplaceholder.typicode.com/

# JWT using KeyCloak (remember that it uses "groups" claim (not roles), these are not enabled by default in keycloak so need to add a mapping)
mp.jwt.verify.publickey.location=https://localhost:9443/auth/realms/quarkus/protocol/openid-connect/certs
mp.jwt.verify.issuer=https://localhost:9443/auth/realms/quarkus
quarkus.smallrye-jwt.auth-mechanism=MP-JWT
quarkus.smallrye-jwt.enabled=true

# Enable console logging
quarkus.log.console.enable=true
quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c] %s%e%n
quarkus.log.console.level=TRACE

# Restrict overall logging to INFO, but allow max insight into JWT
quarkus.log.level=WARN
quarkus.log.category."io.quarkus.smallrye.jwt".level=TRACE
quarkus.log.category."io.undertow.request.security".level=TRACE
quarkus.log.category."io.smallrye.jwt".level=TRACE

# Kafka "start-queue" will produce onto "teedjay-inbound" topic
smallrye.messaging.sink.start-queue.type=io.smallrye.reactive.messaging.kafka.Kafka
smallrye.messaging.sink.start-queue.topic=teedjay-inbound
smallrye.messaging.sink.start-queue.bootstrap.servers=localhost:9092
smallrye.messaging.sink.start-queue.key.serializer=org.apache.kafka.common.serialization.StringSerializer
smallrye.messaging.sink.start-queue.value.serializer=org.apache.kafka.common.serialization.StringSerializer
smallrye.messaging.sink.start-queue.acks=1

# Kafka "inbound-queue" will consume from "teedjay-inbound" topic
smallrye.messaging.source.inbound-queue.type=io.smallrye.reactive.messaging.kafka.Kafka
smallrye.messaging.source.inbound-queue.topic=teedjay-inbound
smallrye.messaging.source.inbound-queue.bootstrap.servers=localhost:9092
smallrye.messaging.source.inbound-queue.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
smallrye.messaging.source.inbound-queue.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
smallrye.messaging.source.inbound-queue.group.id=teedjay-transformer-id

# Kafka "outbound-queue" will produce onto "teedjay-outbound" topic
smallrye.messaging.sink.outbound-queue.type=io.smallrye.reactive.messaging.kafka.Kafka
smallrye.messaging.sink.outbound-queue.topic=teedjay-outbound
smallrye.messaging.sink.outbound-queue.bootstrap.servers=localhost:9092
smallrye.messaging.sink.outbound-queue.key.serializer=org.apache.kafka.common.serialization.StringSerializer
smallrye.messaging.sink.outbound-queue.value.serializer=org.apache.kafka.common.serialization.StringSerializer
smallrye.messaging.sink.outbound-queue.acks=1

# Kafka "end-queue" will consume from "teedjay-outbound" topic
smallrye.messaging.source.end-queue.type=io.smallrye.reactive.messaging.kafka.Kafka
smallrye.messaging.source.end-queue.topic=teedjay-outbound
smallrye.messaging.source.end-queue.bootstrap.servers=localhost:9092
smallrye.messaging.source.end-queue.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
smallrye.messaging.source.end-queue.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
smallrye.messaging.source.end-queue.group.id=teedjay-consumer-id
